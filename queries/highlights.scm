;;;;; Highlight queries for tree-sitter-commonlisp

;;;; Preface

;;; We are using @keyword for names of special forms, such as let,
;;; and @function.macro for macros, such as defun.

;;; Order of query definitions matters: queries that are specified last have 
;;; higher precedence.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

["(" ")"] @punctuation.bracket

(string) @string
(documentation) @string

(number) @number

(t) @boolean

(nil) @constant.builtin

[(pkg_symbol) (symbol)] @variable

(keyword) @lisp.keyword

[(comment) (block_comment)] @comment

(character) @character

;; TODO reduce scope of matched expressions
(list . [(pkg_symbol) (symbol)] @function)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; defun

(defun 
  "defun" @function.macro
  [(fn_name (symbol) @function)
   (fn_name "setf" @function.builtin (symbol) @function)])

(defmacro 
  "defmacro" @function.macro
  name: (symbol) @function)

(defmethod 
  "defmethod" @function.macro
  [(fn_name (symbol) @function)
   (fn_name "setf" @function.builtin (symbol) @function)])

(method_qual) @lisp.keyword

(declare
  "declare" @keyword)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; lambda

(lambda
  "lambda" @keyword)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; lambda-list

(lambda_list 
  (symbol) @parameter)

(lambda_list
  [
   (optvar   . "&optional"     @keyword.lambda var: (symbol) @parameter)
   (restvar  . "&rest"         @keyword.lambda var: (symbol) @parameter) 
   (keyvar   . "&key"          @keyword.lambda var: (symbol) @parameter)
   (auxvar   . "&aux"          @keyword.lambda var: (symbol) @parameter)
   (envvar   . "&environment"  @keyword.lambda var: (symbol) @parameter)
   (wholevar . "&whole"        @keyword.lambda var: (symbol) @parameter)
   (bodyvar  . "&body"         @keyword.lambda var: (symbol) @parameter)
   (keyvar (allow_other_keys) @keyword.lambda .)
   ]
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; defvar, defparameter

(defvar
  "defvar" @function.macro
  name: (symbol) @variable)

(defparameter
  "defparameter" @function.macro
  name: (symbol) @variable)

(defconstant
  "defconstant" @function.macro
  name: (symbol) @variable)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Data and Control Flow

(let
  ["let" "let*"] @keyword)

(let_binds 
  (let_bind var: (symbol) @variable))

(destr_bind "destructuring-bind" @function.macro)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Sharpsign

;; don't touch (character)

(vector . ("#" @character.special 
           . len: (number)? @character.special))

(bitvector . ("#" @character.special 
              . len: (number)? @character.special
              . "*" @character.special))
(bits) @number

(function . "#'" @character.special)
(function . "#'" (symbol) @function)

(uninterned_symbol . "#:" @character.special)

(sharp_dot . "#." @character.special)

(struct . ["#s" "#S"] @character.special 
        . name: (symbol) @structure
        slot: (symbol) @field)

(complex . ["#c" "#C"] @character.special)

(pathname . ["#p" "#P"] @character.special)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; special characters

(dot) @character.special

; (package . _ . ":" @character.special)

; (keyword . ":" @character.special)

(quote . "'" @character.special)

(backquote . "`" @character.special)

(unquote . "," @character.special)

(unquote_splicing . [",@" ",."] @character.special)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Miscellaneous

;; enforce higher precedence than regular symbols
(
 (symbol) @variable.special
 (#match? @variable.special "^\\*.+\\*$")
 )

;; fbound symbols from the COMMON-LISP package generated by misc/symbols.lisp

(
 (symbol) @function.builtin
 (#any-of? @function.builtin
  "eql-specializer-object" "make-instances-obsolete" "generic-function-lambda-list" "add-direct-subclass" "add-direct-method" "method-lambda-list" "class-default-initargs" "slot-definition-name" "ensure-class" "compute-direct-slot-definition-initargs" "slot-makunbound-using-class" "class-precedence-list" "shared-initialize" "compute-default-initargs" "class-direct-subclasses" "generic-function-argument-precedence-order" "generic-function-declarations" "remove-method" "no-next-method" "direct-slot-definition-class" "ensure-class-using-class" "method-call-error-method" "compute-effective-method-as-function" "generic-function-method-class" "make-load-form-saving-slots" "funcallable-standard-instance-access" "remove-direct-subclass" "compute-class-precedence-list" "call-method" "add-method" "specializer-direct-generic-functions" "validate-superclass" "describe-object" "generic-flet" "find-method" "add-dependent" "writer-method-class" "method-call-error-argument-list" "with-slots" "compute-discriminating-function" "intern-eql-specializer" "slot-definition-allocation" "function-keywords" "generic-labels" "class-finalized-p" "method-specializers" "clos-warning" "slot-definition-type" "method-call-error-generic-function" "compute-effective-slot-definition" "defgeneric" "slot-exists-p" "slot-definition-initform" "slot-value-using-class" "slot-boundp-using-class" "method-function" "initialize-instance" "standard-instance-access" "class-name" "compute-applicable-methods" "remove-direct-method" "define-method-combination" "find-method-combination" "make-method" "no-primary-method" "specializer-direct-methods" "compute-effective-slot-definition-initargs" "invalid-method-error" "compute-effective-method" "class-prototype" "compute-slots" "class-slots" "set-funcallable-instance-function" "update-instance-for-different-class" "defmethod" "allocate-instance" "update-dependent" "print-object" "method-combination-error" "update-instance-for-redefined-class" "extract-lambda-list" "class-direct-superclasses" "slot-definition-initargs" "change-class" "slot-definition-readers" "slot-definition-writers" "remove-dependent" "slot-missing" "make-instance" "map-dependents" "documentation" "find-class" "reader-method-class" "class-direct-slots" "accessor-method-slot-definition" "class-of" "method-generic-function" "slot-unbound" "effective-slot-definition-class" "ensure-generic-function" "make-load-form" "generic-function-method-combination" "compute-applicable-methods-using-classes" "defclass" "slot-definition-location" "method-qualifiers" "class-direct-default-initargs" "slot-boundp" "generic-function-name" "slot-definition-initfunction" "no-applicable-method" "extract-specializer-names" "finalize-inheritance" "with-accessors" "generic-function-methods" "ensure-generic-function-using-class" "reinitialize-instance" "slot-makunbound" "slot-value" "do-external-symbols" "find-all-symbols" "member-if" "lognot" "open-stream-p" "find-package" "dotimes" "format" "string>=" "fifth" "cdaadr" "slot-value" "truncate" "ftruncate" "invalid-method-error" "function-keywords" "array-total-size" "digit-char" "not" "make-synonym-stream" "print" "type-of" "file-string-length" "pprint-newline" "sort" "method-combination-error" "nsubstitute" "rotatef" "char-not-lessp" "princ" "delete-duplicates" "digit-char-p" "cdaar" "set-pprint-dispatch" "ash" "etypecase" "acos" "asinh" "load-time-value" "float" "user-homedir-pathname" "write-string" "ignore-errors" "array-element-type" "room" "cosh" "char<=" "subst-if-not" "complexp" "check-type" ">=" "list-all-packages" "logtest" "nstring-downcase" "maphash" "typecase" "consp" "caddar" "get-internal-run-time" "machine-instance" "char" "make-concatenated-stream" "ldb-test" "max" "slot-exists-p" "bit-nor" "simple-condition-format-arguments" "array-row-major-index" "bit-not" "unexport" "eql" "make-method" "assoc-if-not" "pathname" "output-stream-p" "parse-namestring" "remove-method" "float-digits" "map" "string<=" "ceiling" "some" "delete-if-not" "defmethod" "ctypecase" "with-slots" "sixth" "nreverse" "caaaar" "rational" "error" "butlast" "nintersection" "getf" "nreconc" "with-package-iterator" "nstring-capitalize" "make-dispatch-macro-character" "cerror" "log" "package-name" "fresh-line" "write-sequence" "fboundp" "set-exclusive-or" "hash-table-test" "read-sequence" "handler-bind" "software-version" "unwind-protect" "update-instance-for-different-class" "bit-eqv" "cos" "cddaar" "subst-if" "position-if-not" "caddr" "decode-float" "append" "<=" "find-if" "continue" "hash-table-rehash-size" "acons" "pprint-fill" "slot-makunbound" "write-line" "sinh" "get-dispatch-macro-character" "mismatch" "eval" "set-macro-character" "read-from-string" "gensym" "lambda" "symbol-plist" "byte-size" "ecase" "find-if-not" "warn" "schar" "machine-version" "string-greaterp" "file-namestring" "package-nicknames" "define-modify-macro" "decf" "string-not-greaterp" "array-has-fill-pointer-p" "count" "long-site-name" "cadr" "list-length" "defclass" "pathname-match-p" "nconc" "char-int" "byte" "logand" "defparameter" "upgraded-array-element-type" "graphic-char-p" "disassemble" "get-decoded-time" "char-upcase" "destructuring-bind" "assoc" "rassoc" "class-name" "with-simple-restart" "makunbound" "array-dimensions" "cis" "make-package" "char-not-greaterp" "file-error-pathname" "complement" "sqrt" "let*" "make-string-input-stream" "pop" "class-of" "with-output-to-string" "read-char" "logical-pathname-translations" "copy-alist" "map-into" "fmakunbound" "stream-element-type" "define-condition" "pairlis" "two-way-stream-output-stream" "make-echo-stream" "directory-namestring" "defun" "bit-vector-p" "oddp" "assoc-if" "step" "make-condition" "write-char" "write" "bit-orc1" "isqrt" "last" "cons" "lisp-implementation-type" "bit-orc2" "make-broadcast-stream" "with-open-file" "and" "clrhash" "multiple-value-setq" "gethash" "keywordp" "listen" "revappend" "load" "cadar" "function-lambda-expression" "delete-package" "merge-pathnames" "rassoc-if" "cond" "atom" "rename-file" "logorc1" "copy-pprint-dispatch" "signal" "integer-decode-float" "string-not-lessp" "replace" "logorc2" "find-symbol" "compiled-function-p" "call-method" "nsubst-if" "notany" "cadddr" "sbit" "elt" "fround" "get-properties" "make-string" "constantp" "values" "describe-object" "defconstant" "slot-boundp" "set-dispatch-macro-character" "defmacro" "constantly" "read" "method-qualifiers" "upper-case-p" "ensure-generic-function" "round" "return-from" "length" "remove-duplicates" "caar" "caaadr" "when" "package-use-list" "string" "parse-integer" "count-if" "simple-condition-format-control" "copy-structure" "code-char" "macro-function" "multiple-value-list" "name-char" "compute-applicable-methods" "untrace" "file-length" "hash-table-count" "string-downcase" "synonym-stream-symbol" "vector-push" "file-position" "adjustable-array-p" "mapl" "string-left-trim" "array-dimension" "substitute-if-not" "nstring-upcase" "prog2" "float-sign" "defgeneric" "aref" "vectorp" "prog1" "pushnew" "mapc" "let" "cddadr" "atanh" "prog*" "muffle-warning" "symbol-macrolet" "equalp" "print-not-readable-object" "echo-stream-output-stream" "alpha-char-p" "deftype" "adjoin" "cdadar" "char-name" "deposit-field" "define-method-combination" "pprint-tab" "get-setf-expansion" "minusp" "unread-char" "translate-logical-pathname" "flet" "subtypep" "lisp-implementation-version" "import" "with-open-stream" "copy-seq" "quote" "broadcast-stream-streams" "directory" "adjust-array" "position" "progv" "ninth" "string-upcase" "numberp" "enough-namestring" "eval-when" "substitute" "simple-vector-p" "terpri" "progn" "print-object" "find-class" "delete-if" "functionp" "standard-char-p" "simple-string-p" "imagpart" "encode-universal-time" "get-output-stream-string" "or" "two-way-stream-input-stream" "macroexpand" "decode-universal-time" "lower-case-p" "symbol-name" "ldb" "compile-file-pathname" "concatenate" "make-hash-table" "read-delimited-list" "scale-float" "nsubstitute-if" "with-accessors" "pprint-dispatch" "rem" "logior" "shiftf" "symbol-value" "cdr" "cadaar" "second" "incf" "string-not-equal" "float-precision" "random-state-p" "push" "no-applicable-method" "logxor" "namestring" "compile-file" "string-equal" "fill" "handler-case" "vector" "tanh" "interactive-stream-p" "pprint-indent" "probe-file" "stream-error-stream" "throw" "packagep" "pathname-name" "boundp" "realpart" "denominator" "arithmetic-error-operands" "funcall" "nth-value" "defstruct" "cdddr" "nsubst" "read-line" "byte-position" "cell-error-name" "readtablep" "break" "string-trim" "store-value" "logcount" "complex" "rassoc-if-not" "pathname-version" "restart-case" "fceiling" "the" "merge" "update-instance-for-redefined-class" "caadr" "if" "svref" "special-operator-p" "psetq" "nset-exclusive-or" "read-char-no-hang" "setq" "list" "with-input-from-string" "get" "gentemp" "symbol-package" "sxhash" "hash-table-rehash-threshold" "coerce" "assert" "nsubst-if-not" "setf" "string-lessp" "symbolp" "psetf" "make-load-form-saving-slots" "notevery" "bit-and" "ffloor" "block" "pathnamep" "tenth" "floor" "vector-pop" "find" "apropos-list" "numerator" "reinitialize-instance" "character" "multiple-value-prog1" "wild-pathname-p" "file-author" "echo-stream-input-stream" "make-sequence" "integerp" "car" "get-macro-character" "defpackage" "make-array" "values-list" "make-two-way-stream" "floatp" "unuse-package" "loop-finish" "bit-andc1" "cdaddr" "dpb" "with-standard-io-syntax" "bit-andc2" "rename-package" "unbound-slot-instance" "define-symbol-macro" "char-code" "copy-symbol" "every" "nth" "vector-push-extend" "time" "finish-output" "open" "member-if-not" "copy-readtable" "invoke-restart" "nset-difference" "change-class" "set-difference" "inspect" "first" "cddar" "add-method" "force-output" "pathname-directory" "delete" "rest" "string>" "mod" "lcm" "string<" "copy-tree" "rplacd" "string=" "subsetp" "in-package" "reverse" "formatter" "slot-unbound" "rplaca" "describe" "nbutlast" "remhash" "pprint-tabular" "logeqv" "type-error-expected-type" "caaar" "expt" "do-symbols" "float-radix" "both-case-p" "stringp" "array-in-bounds-p" "proclaim" "simple-bit-vector-p" "equal" "no-next-method" "write-to-string" "bit" "cadadr" "copy-list" "make-string-output-stream" "char-greaterp" "third" "write-byte" "asin" "char-downcase" "caadar" "case" "eq" "member" "tagbody" "random" "translate-pathname" "fill-pointer" "substitute-if" "locally" "search" "multiple-value-call" "find-method" "clear-input" "documentation" "clear-output" "ed" "read-byte" "min" "find-restart" "eighth" "make-list" "char-not-equal" "readtable-case" "shadowing-import" "get-internal-real-time" "array-rank" "endp" "labels" "char/=" "signum" "atan" "cdddar" "concatenated-stream-streams" "conjugate" "characterp" "pprint" "make-instance" "close" "input-stream-p" "do" "exp" "package-shadowing-symbols" "remf" "mapcon" "prin1-to-string" "1-" "realp" "1+" "short-site-name" "rationalp" "invoke-debugger" "char-lessp" "yes-or-no-p" "cdaaar" "pprint-linear" "do*" "with-compilation-unit" "slot-missing" "make-symbol" "char>" "array-displacement" "char=" "nthcdr" "char<" "machine-type" "apply" "remove-if-not" "cddr" "sin" "go" "remove" "abs" "loop" "shared-initialize" "remove-if" "phase" "streamp" "return" "software-type" "identity" "y-or-n-p" "with-condition-restarts" "nsublis" "sublis" "evenp" "pprint-logical-block" "ccase" "symbol-function" "lognand" "macroexpand-1" "bit-ior" "alphanumericp" "maplist" "host-namestring" "seventh" "make-instances-obsolete" "string-right-trim" "make-pathname" "nsubstitute-if-not" "/=" "trace" "stream-external-format" "type-error-datum" "compile" "princ-to-string" "reduce" "package-error-package" "bit-nand" "tan" "hash-table-size" "get-universal-time" "stable-sort" "shadow" "apropos" "gcd" "position-if" "bit-xor" "read-preserving-whitespace" "mapcan" "abort" "restart-name" "listp" "char-equal" "mapcar" "tree-equal" "intersection" "row-major-aref" "defvar" "pathname-device" "initialize-instance" "string-capitalize" "count-if-not" "use-value" "subst" "string/=" "package-used-by-list" "null" "require" "truename" "print-unreadable-object" "peek-char" "unintern" "boole" "dribble" "prin1" "use-package" "ldiff" "typep" "pathname-host" ">" "function" "=" "<" "arrayp" "hash-table-p" "compute-restarts" "zerop" "delete-file" "export" "cdadr" "rationalize" "ensure-directories-exist" "define-compiler-macro" "prog" "tailp" "list*" "make-random-state" "upgraded-complex-part-type" "/" "restart-bind" "-" "do-all-symbols" "fourth" "pathname-type" "+" "*" "fdefinition" "cdar" "caaddr" "allocate-instance" "nunion" "acosh" "logandc1" "macrolet" "unless" "logandc2" "arithmetic-error-operation" "catch" "mask-field" "logbitp" "remprop" "declaim" "union" "define-setf-expander" "make-load-form" "logical-pathname" "char>=" "intern" "plusp" "invoke-restart-interactively" "multiple-value-bind" "sleep" "subseq" "set" "cddddr" "file-write-date" "defsetf" "set-syntax-from-char" "with-hash-table-iterator" "load-logical-pathname-translations" "provide" "dolist" "integer-length" "compiler-macro-function" "declare" "lognor"
  )
 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; quoted forms

;; defined last to have high precedence

;; generated by query-gen.lisp

(quote (symbol) @variable) 
(quote (list (symbol) @variable)) 
(quote (list (list (symbol) @variable))) 
(quote (list (list (list (symbol) @variable)))) 
(quote (list (list (list (list (symbol) @variable))))) 
(quote (list (list (list (list (list (symbol) @variable)))))) 
(quote (list (list (list (list (list (list (symbol) @variable))))))) 
(quote (list (list (list (list (list (list (list (symbol) @variable)))))))) 
(quote (list (list (list (list (list (list (list (list (symbol) @variable))))))))) 
(quote (list (list (list (list (list (list (list (list (list (symbol) @variable)))))))))) 
(backquote (symbol) @variable) 
(backquote (list (symbol) @variable)) 
(backquote (list (list (symbol) @variable))) 
(backquote (list (list (list (symbol) @variable)))) 
(backquote (list (list (list (list (symbol) @variable))))) 
(backquote (list (list (list (list (list (symbol) @variable)))))) 
(backquote (list (list (list (list (list (list (symbol) @variable))))))) 
(backquote (list (list (list (list (list (list (list (symbol) @variable)))))))) 
(backquote (list (list (list (list (list (list (list (list (symbol) @variable))))))))) 
(backquote (list (list (list (list (list (list (list (list (list (symbol) @variable))))))))))
